Unit Service.UploadImage;

Interface

Uses
    System.SysUtils,
    System.Classes,
    System.Generics.Collections,
    MVCFramework.ActiveRecord,
    FireDAC.Comp.Client,
    Web.ReqFiles,
    Service.Interfaces;

Type
    TImageUploadService = Class(TInterfacedObject, IImageUploadService)
    Public
        Function SaveUploadedImages(Const AFiles: TWebRequestFiles; Const AUserID: String): Boolean;
    End;

Implementation

Uses
    System.IOUtils,
    System.DateUtils,
    System.Math,
    System.StrUtils,
    MVCFramework.Logger,
    FireDac.Stan.Param,
    Data.DB,
    Graphics,
    System.Generics.Collections; // برای TDictionary

{ TImageUploadService }

//________________________________________________________________________________________
Function TImageUploadService.SaveUploadedImages(
    Const AFiles: TWebRequestFiles; Const AUserID: String): Boolean;
Var
    i, j, k: Integer;
    LConn: TFDConnection;
    LQuery: TFDQuery;
    LAssignQuery: TFDQuery;
    LGUIDFolder, LBaseUploadsDir, LThisFolder: String;
    LTempFiles: TStringList;
    LUploadedIDs: TList<Int64>;
    LBranchIDs: TList<Int64>;
    LMem: TMemoryStream;
    LFileSizeKB: Integer;
    LOrigName, LContentType: String;
    LImagePhoneID: Int64;

    LBitmap: TBitmap;
    LWidth, LHeight: Integer;

    BranchMap: TDictionary<Int64, TList<Int64>>;
    sb: TStringBuilder;

    // متغیرهای کمکی محلی
    AID: Int64;
    BID: Int64;
    assignID: Int64;
    aID2: Int64;
    bID: Int64;
    ImageID: Int64;
    targetBranchIdx: Integer;
    targetBranchID: Int64;
    assigned, found: Boolean;

    Function GetLastInsertID: Int64;
    Begin
        // این تابع برای MySQL نوشته شده است.
        LQuery.SQL.Text := 'SELECT LAST_INSERT_ID() AS id';
        LQuery.Open;
        Try
            Result := LQuery.FieldByName('id').AsLargeInt;
        Finally
            LQuery.Close;
        End;
    End;

Begin
    Result := False;

    If (AFiles = Nil) Or (AFiles.Count = 0) Then
        Exit;

    // مسیر ذخیره کنار exe: /uploads/{GUID}/
    LBaseUploadsDir := TPath.Combine(ExtractFilePath(ParamStr(0)), 'uploads');
    If Not TDirectory.Exists(LBaseUploadsDir) Then
        TDirectory.CreateDirectory(LBaseUploadsDir);

    LGUIDFolder := TGUID.NewGuid.ToString;
    LThisFolder := TPath.Combine(LBaseUploadsDir, LGUIDFolder);
    ForceDirectories(LThisFolder);

    LTempFiles := TStringList.Create;
    LUploadedIDs := TList<Int64>.Create;
    LBranchIDs := TList<Int64>.Create;
    LQuery := TFDQuery.Create(Nil);
    LAssignQuery := Nil;
    LMem := Nil;
    LBitmap := Nil;
    BranchMap := Nil;
    sb := Nil;

    Try
        LConn := TMVCActiveRecord.CurrentConnection As TFDConnection;
        If LConn = Nil Then
            Raise Exception.Create('ارتباط با دیتابیس برقرار نیست');

        LConn.StartTransaction;

        // حلقه روی فایل‌های دریافتی
        For i := 0 To AFiles.Count - 1 Do
        Begin
            // فرض: AFiles.Items[i].FileName و .ContentType و .Stream موجود است
            LOrigName := AFiles.Items[i].FileName;
            LContentType := AFiles.Items[i].ContentType;

            // Stream الزامی است در این پیاده‌سازی
            If Not Assigned(AFiles.Items[i].Stream) Then
                Raise Exception.CreateFmt('فایل %s استریم ندارد - قابلیت خواندن استریم پشتیبانی نشده', [LOrigName]);

            LMem := TMemoryStream.Create;
            Try
                // خواندن کامل استریم ورودی به مموری
                AFiles.Items[i].Stream.Position := 0;
                LMem.CopyFrom(AFiles.Items[i].Stream, AFiles.Items[i].Stream.Size);

                // ذخیره روی دیسک (نام اصلی فایل - در صورت نیاز می‌توان با GUID ذخیره کرد)
                LMem.Position := 0;
                LMem.SaveToFile(TPath.Combine(LThisFolder, LOrigName));
                LTempFiles.Add(TPath.Combine(LThisFolder, LOrigName));

                // محاسبه اندازه فایل به KB
                LFileSizeKB := Ceil(TFile.GetSize(LTempFiles[LTempFiles.Count - 1]) / 1024);

                // تلاش برای خواندن عرض/ارتفاع (اگر سرور امکان بارگذاری VCL دارد)
                LWidth := 0;
                LHeight := 0;
                Try
                    LBitmap := TBitmap.Create;
                    Try
                        LBitmap.LoadFromFile(LTempFiles[LTempFiles.Count - 1]);
                        LWidth := LBitmap.Width;
                        LHeight := LBitmap.Height;
                    Finally
                        FreeAndNil(LBitmap);
                    End;
                Except
                    // اگر نتوانستیم ابعاد را بفهمیم، صفر می‌گذاریم
                    LWidth := 0;
                    LHeight := 0;
                End;

                // درج رکورد در customer_assign_image_phone
                LQuery.Connection := LConn;
                LQuery.SQL.Text :=
                  'INSERT INTO customer_assign_image_phone (ImageGuid, UploadDate, FileSizeKB, ContentType, OriginalFileName, Width, Height) ' +
                  'VALUES (:g, :ud, :fs, :ct, :on, :w, :h)';

                LQuery.ParamByName('g').AsString := LGUIDFolder;
                LQuery.ParamByName('ud').AsDateTime := Now;
                LQuery.ParamByName('fs').AsInteger := LFileSizeKB;
                LQuery.ParamByName('ct').AsString := LContentType;
                LQuery.ParamByName('on').AsString := LOrigName;
                LQuery.ParamByName('w').AsInteger := LWidth;
                LQuery.ParamByName('h').AsInteger := LHeight;

                LQuery.ExecSQL;

                // گرفتن ID آخرین درج (MySQL)
                LImagePhoneID := GetLastInsertID;
                LUploadedIDs.Add(LImagePhoneID);

            Finally
                FreeAndNil(LMem);
            End;
        End;

        // خواندن BranchID ها
        LQuery.SQL.Text := 'SELECT BranchID FROM branch_branch ORDER BY BranchID';
        LQuery.Open;
        Try
            While Not LQuery.Eof Do
            Begin
                LBranchIDs.Add(LQuery.FieldByName('BranchID').AsLargeInt);
                LQuery.Next;
            End;
        Finally
            LQuery.Close;
        End;

        If LBranchIDs.Count = 0 Then
            Raise Exception.Create('هیچ شاخه‌ای برای تخصیص یافت نشد');

        // تهیه لیست assignment های خالی برای هر شعبه
        LAssignQuery := TFDQuery.Create(Nil);
        Try
            LAssignQuery.Connection := LConn;

            // ساختن رشته لیست شاخه‌ها
            sb := TStringBuilder.Create;
            Try
                For j := 0 To LBranchIDs.Count - 1 Do
                Begin
                    If j > 0 Then
                        sb.Append(', ');
                    sb.Append(LBranchIDs[j].ToString);
                End;

                LAssignQuery.SQL.Text := Format(
                  'SELECT AssignmentID, BranchID FROM customer_assignment WHERE BranchID IN (%s) AND ImagePhoneID IS NULL ORDER BY BranchID, AssignmentID',
                  [sb.ToString]
                );
            Finally
                FreeAndNil(sb);
            End;

            LAssignQuery.Open;

            // ساخت Map: BranchID -> لیست AssignmentID خالی
            BranchMap := TDictionary<Int64, TList<Int64>>.Create;
            Try
                For j := 0 To LBranchIDs.Count - 1 Do
                    BranchMap.Add(LBranchIDs[j], TList<Int64>.Create);

                While Not LAssignQuery.Eof Do
                Begin
                    AID := LAssignQuery.FieldByName('AssignmentID').AsLargeInt;
                    BID := LAssignQuery.FieldByName('BranchID').AsLargeInt;
                    If BranchMap.ContainsKey(BID) Then
                        BranchMap[BID].Add(AID);
                    LAssignQuery.Next;
                End;

                LAssignQuery.Close;

                // round-robin تخصیص
                For j := 0 To LUploadedIDs.Count - 1 Do
                Begin
                    ImageID := LUploadedIDs[j];
                    targetBranchIdx := j Mod LBranchIDs.Count;
                    targetBranchID := LBranchIDs[targetBranchIdx];
                    assigned := False;

                    // اگر assignment خالی برای آن شاخه هست استفاده کن
                    If BranchMap.ContainsKey(targetBranchID) And (BranchMap[targetBranchID].Count > 0) Then
                    Begin
                        assignID := BranchMap[targetBranchID][0];
                        BranchMap[targetBranchID].Delete(0);

                        LQuery.SQL.Text := 'UPDATE customer_assignment SET ImagePhoneID = :img WHERE AssignmentID = :aid';
                        LQuery.ParamByName('img').AsLargeInt := ImageID;
                        LQuery.ParamByName('aid').AsLargeInt := assignID;
                        LQuery.ExecSQL;

                        assigned := True;
                    End
                    Else
                    Begin
                        // جستجو در سایر شاخه‌ها برای assignment خالی
                        found := False;
                        For k := 0 To LBranchIDs.Count - 1 Do
                        Begin
                            bID := LBranchIDs[k];
                            If BranchMap.ContainsKey(bID) And (BranchMap[bID].Count > 0) Then
                            Begin
                                aID2 := BranchMap[bID][0];
                                BranchMap[bID].Delete(0);

                                LQuery.SQL.Text := 'UPDATE customer_assignment SET ImagePhoneID = :img WHERE AssignmentID = :aid';
                                LQuery.ParamByName('img').AsLargeInt := ImageID;
                                LQuery.ParamByName('aid').AsLargeInt := aID2;
                                LQuery.ExecSQL;

                                found := True;
                                Break;
                            End;
                        End;
                        If found Then
                            assigned := True;
                    End;

                    If Not assigned Then
                    Begin
                        // fallback: درج نگاشت در جدول جداگانه
                        LQuery.SQL.Text := 'INSERT INTO customer_assign_image_phone_branch (ImagePhoneID, BranchID) VALUES (:img, :br)';
                        LQuery.ParamByName('img').AsLargeInt := ImageID;
                        LQuery.ParamByName('br').AsLargeInt := targetBranchID;
                        LQuery.ExecSQL;
                    End;
                End;

                // آزادسازی BranchMap و لیست‌های داخلی
                For k := 0 To LBranchIDs.Count - 1 Do
                Begin
                    If BranchMap.ContainsKey(LBranchIDs[k]) Then
                        BranchMap[LBranchIDs[k]].Free;
                End;
                FreeAndNil(BranchMap);

            Finally
                // در صورت استثنا نیز پاکسازی
                If Assigned(BranchMap) Then
                Begin
                    For k := 0 To LBranchIDs.Count - 1 Do
                        If BranchMap.ContainsKey(LBranchIDs[k]) Then
                            BranchMap[LBranchIDs[k]].Free;
                    FreeAndNil(BranchMap);
                End;
            End;

        Finally
            FreeAndNil(LAssignQuery);
        End;

        // Commit تراکنش
        LConn.Commit;
        Result := True;

    Except
        On E: Exception Do
        Begin
            // rollback و پاکسازی فایل‌های محلی
            Try
                If Assigned(LConn) And LConn.InTransaction Then
                    LConn.Rollback;
            Except
            End;

            Try
                For i := 0 To LTempFiles.Count - 1 Do
                    If TFile.Exists(LTempFiles[i]) Then
                        TFile.Delete(LTempFiles[i]);
                If TDirectory.Exists(LThisFolder) Then
                    TDirectory.Delete(LThisFolder, True);
            Except
            End;

            // بالا بردن خطا برای لاگ یا پاسخ مناسب در controller
            Raise;
        End;
    Finally
        LTempFiles.Free;
        LUploadedIDs.Free;
        LBranchIDs.Free;
        FreeAndNil(LQuery);
    End;
End;
//________________________________________________________________________________________

End.

